import { z } from "zod";
import * as db from "./db";

/**
 * Schema for the intelligence data JSON sent from the Manus AI processing engine
 */
export const IntelligenceDataSchema = z.object({
  // Metadata
  meetingDate: z.string(),
  primaryLead: z.string(),
  participants: z.array(z.string()),
  organizations: z.array(z.string()).optional(),
  jurisdictions: z.array(z.string()).optional(),
  
  // Intelligence Content
  executiveSummary: z.string(),
  strategicHighlights: z.array(z.string()).optional(),
  opportunities: z.array(z.string()).optional(),
  risks: z.array(z.string()).optional(),
  keyQuotes: z.array(z.string()).optional(),
  intelligenceData: z.record(z.string(), z.any()).optional(),
  
  // Full transcript
  fullTranscript: z.string().optional(),
  
  // Source tracking
  sourceType: z.enum(["plaud", "fathom", "manual"]),
  sourceId: z.string().optional(),
  
  // Tags
  sectors: z.array(z.string()).optional(),
  jurisdictionTags: z.array(z.string()).optional(),
  
  // Action items
  actionItems: z.array(z.object({
    title: z.string(),
    description: z.string().optional(),
    priority: z.enum(["low", "medium", "high"]).optional(),
    assignedTo: z.string().optional(), // Name, not ID
    dueDate: z.string().optional(),
  })).optional(),
});

export type IntelligenceData = z.infer<typeof IntelligenceDataSchema>;

/**
 * Process incoming intelligence data and store it in the database
 */
export async function processIntelligenceData(data: IntelligenceData, createdBy?: number) {
  // Check for duplicate by sourceId
  if (data.sourceId) {
    const existing = await db.getMeetingsBySourceId(data.sourceId);
    if (existing.length > 0) {
      console.log(`[Ingestion] Duplicate meeting detected with sourceId: ${data.sourceId}`);
      return { success: false, reason: "duplicate", meetingId: existing[0]?.id };
    }
  }

  // Create the meeting
  const meetingId = await db.createMeeting({
    meetingDate: new Date(data.meetingDate),
    primaryLead: data.primaryLead,
    participants: JSON.stringify(data.participants),
    organizations: data.organizations ? JSON.stringify(data.organizations) : null,
    jurisdictions: data.jurisdictions ? JSON.stringify(data.jurisdictions) : null,
    executiveSummary: data.executiveSummary,
    strategicHighlights: data.strategicHighlights ? JSON.stringify(data.strategicHighlights) : null,
    opportunities: data.opportunities ? JSON.stringify(data.opportunities) : null,
    risks: data.risks ? JSON.stringify(data.risks) : null,
    keyQuotes: data.keyQuotes ? JSON.stringify(data.keyQuotes) : null,
    intelligenceData: data.intelligenceData ? JSON.stringify(data.intelligenceData) : null,
    fullTranscript: data.fullTranscript ?? null,
    sourceType: data.sourceType,
    sourceId: data.sourceId ?? null,
    createdBy: createdBy ?? null,
  });

  // Process sector tags
  if (data.sectors && data.sectors.length > 0) {
    for (const sectorName of data.sectors) {
      const tag = await db.getOrCreateTag(sectorName, "sector");
      if (tag) {
        await db.addTagToMeeting(meetingId, tag.id);
      }
    }
  }

  // Process jurisdiction tags
  if (data.jurisdictionTags && data.jurisdictionTags.length > 0) {
    for (const jurisdictionName of data.jurisdictionTags) {
      const tag = await db.getOrCreateTag(jurisdictionName, "jurisdiction");
      if (tag) {
        await db.addTagToMeeting(meetingId, tag.id);
      }
    }
  }

  // Process action items
  if (data.actionItems && data.actionItems.length > 0) {
    for (const item of data.actionItems) {
      // Try to find user by name if assignedTo is provided
      let assignedUserId: number | null = null;
      if (item.assignedTo) {
        const users = await db.getAllUsers();
        const user = users.find(u => u.name?.toLowerCase() === item.assignedTo?.toLowerCase());
        if (user) {
          assignedUserId = user.id;
        }
      }

      await db.createTask({
        title: item.title,
        description: item.description ?? null,
        priority: item.priority ?? "medium",
        assignedTo: assignedUserId,
        meetingId: meetingId,
        dueDate: item.dueDate ? new Date(item.dueDate) : null,
        isAutoGenerated: true,
        createdBy: createdBy ?? null,
      });
    }
  }

  console.log(`[Ingestion] Successfully processed meeting ${meetingId} from ${data.sourceType}`);
  
  return { success: true, meetingId };
}

/**
 * Validate and parse intelligence data from webhook
 */
export function validateIntelligenceData(rawData: unknown): IntelligenceData | null {
  try {
    return IntelligenceDataSchema.parse(rawData);
  } catch (error) {
    console.error("[Ingestion] Validation error:", error);
    return null;
  }
}
